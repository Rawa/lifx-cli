#!/usr/bin/python2.7

#
# Simple script to control your LIFX lamps using the cli by doing RESTful calls
# to the lifx api. Needs a valid lifx token to make requests, the token should
# be saved in $HOME/.config/lifx/lifx_token
#
# @author David Goransson
#

from StringIO import StringIO
import os
import pycurl
import sys
import json
import argparse

version = '1.0b'
verbose = False
URL = 'https://api.lifx.com/v1/lights/SELECTOR/ACTION'
actions = ("on", "off", "toggle", "list", "state", "--version")
home = os.getenv("HOME")
config_path = home + "/.config/lifx/lifx_token"

if not os.path.exists(config_path):
    print("No config found!")
    print("  1. Get your developer lifx token:")
    print("     https://cloud.lifx.com/")
    print("  2. Save your lifx token to ")
    print("     " + config_path)
    print("  3. ????")
    print("  4. Profit!")
    sys.exit(1)

f = open(config_path,'r')
token = f.readline().rstrip()
f.close()

############### ConnectionHandle ###################
class ConnectionHandle:
    def ___init__(self):
        pass

    def _send_request(self, c):
        storage = StringIO()

        c.setopt(c.WRITEFUNCTION, storage.write)
        c.setopt(pycurl.CONNECTTIMEOUT, 5)
        c.setopt(pycurl.TIMEOUT, 5)
        c.setopt(pycurl.USERPWD, token)
        try:
           c.perform()
        except pycurl.error:
            error_exit("Timeout - Unable to reach the server, verify your internet connection")

        content = storage.getvalue()
        http_code = c.getinfo(pycurl.HTTP_CODE)
        c.close()
        self._handle_response(http_code, content)
        return http_code, content

    def _handle_response(self, code, content):
        if code in (200 ,201, 202, 207):
            #Everything is fine, exit program peacefully
            return;
        elif code == 401:
            print("Unauthorized request - Verify your lifx token")
        elif code == 408:
            print("Request timed out -  Light unreachable!")
        elif code == 422:
            print("Unprocessable Entity - Missing or malformed parameters.")
        elif code == 429:
            print("Too many requests!")
        elif code in (500, 502, 503, 523):
            print("Server error!")
        else:
            print("Unknown error! HTTP Code: " + str(code))

        decoded = json.loads(content)
        if decoded['error']:
            error_exit("Error: " + decoded['error'])
        else:
            print("Server response:")
            error_exit(content)

    def _build_url(self, selector, action):
        url = URL.replace("SELECTOR", selector)
        url = url.replace("ACTION", action)
        return url

    def send_put(self, selector, action, data):
        c = pycurl.Curl()
        c.setopt(pycurl.CUSTOMREQUEST, "PUT")
        c.setopt(pycurl.URL, self._build_url(selector, action))
        c.setopt(pycurl.POSTFIELDS, data)
        return self._send_request(c);

    def send_post(self, selector, action, data):
        c = pycurl.Curl()
        c.setopt(pycurl.POST, 1)
        c.setopt(pycurl.POSTFIELDS, data)
        c.setopt(pycurl.URL, self._build_url(selector, action))
        return self._send_request(c)

    def send_get(self, selector):
        c = pycurl.Curl()
        c.setopt(pycurl.URL, self._build_url(selector, ""))
        return self._send_request(c)

############### LIFX ###################
class LIFX:
    def ___init__(self):
        pass

    ############### LIST ################
    # LIST: GET /v1/lights/:selector
    def list(self, args):
        print(args)
        selector = self._get_selector(args)
        code, content = ConnectionHandle().send_get(selector)

        # Parse and print response
        decoded = json.loads(content)

        if args.verbose:
            print("[Label] - [Location]/[Group]\n")
            for item in decoded:
                print(item['label'] + " - " + item['location']['name'] + "/" + item['group']['name'])
                print("  power      : " + item['power'])
                print("  hue        : " + str(item['color']['hue']))
                print("  kelvin     : " + str(item['color']['kelvin']))
                print("  saturation : " + str(item['color']['saturation']))
                print("  brightness : " + str(item['brightness']))
        else:
            longestLabel = len(max([item['label'] for item in decoded], key=len))
            for item in decoded:
                print(("{:" + str(longestLabel) + "} {}").format(item['label'], item['power']))


    ############### TOGGLE ################
    # TOGGLE: POST /v1/lights/:selector/toggle
    def toggle(self, args):
        return ConnectionHandle().send_post(self._get_selector(args), "toggle", "duration=" + str(args.duration))

    ############### POWER ################
    # STATE: PUT /v1/lights/:selector/state
    def power(self, args):
        data=""

        #power=
        if args.power:
            data+="power=" + args.power

        #duration=
        if args.duration is not None:
            data+="&duration=" + str(args.duration)

        selector = self._get_selector(args)
        ConnectionHandle().send_put(selector, "state", data)

    ############### STATE ################
    # STATE: PUT /v1/lights/:selector/state
    def state(self, args):
        data=""

        print(args)
        #power=
        if args.power:
            data+="power=" + args.power

        #duration=
        if args.duration is not None:
            data+="&duration=" + str(args.duration)

        #color=
        if not_none_exists(args.color,
                           args.rgb,
                           args.hue,
                           args.saturation,
                           args.brightness,
                           args.kelvin):
            color = ""
            if args.color:
                color+=args.color
            elif args.rgb:
                color+="rgb:" + (",").join(map(str, args.rgb))

            # 0 = False, thus compare with None
            if args.hue is not None:
                color+=" hue:" + str(args.hue)
            if args.saturation is not None:
                color+=" saturation:" + str(args.saturation)
            if args.brightness is not None:
                color+=" brightness:" + str(args.brightness)
            if args.kelvin is not None:
                color+=" kelvin:" + str(args.kelvin)

            if color.startswith(' '):
                color=color[1:]
            data+="&color=" + color

        selector = self._get_selector(args)
        ConnectionHandle().send_put(selector, "state", data)

    def _get_selector(self, args):
        if args.label:
            return "label:" + args.label
        elif args.location:
            return "location:" + args.location
        elif args.group:
            return "group:" + args.group
        else:
            return "all"

############### Parser ###################
class Parser:
    def ___init__(self):
        pass

    def parser(self):
        parser = argparse.ArgumentParser(description='Command line interface for LIFX light bulbs.')
        subparsers = parser.add_subparsers(dest="sub_action", title='Subcommands',
            description='state, toggle',
            help='additional help')
        self._on_parser(subparsers)
        self._off_parser(subparsers)
        self._list_parser(subparsers)
        self._state_parser(subparsers)
        self._toggle_parser(subparsers)
        return parser

    def _on_parser(self, subparsers):
        on_parser = subparsers.add_parser('on')
        on_parser.set_defaults(power='on')
        self._addDurationArgument(on_parser)
        self._addSelectorGroup(on_parser)

    def _off_parser(self, subparsers):
        off_parser = subparsers.add_parser('off')
        off_parser.set_defaults(power='off')
        self._addDurationArgument(off_parser)
        self._addSelectorGroup(off_parser)

    def _list_parser(self, subparsers):
        list_parser = subparsers.add_parser('list')
        self._addVerboseArgument(list_parser)
        self._addSelectorGroup(list_parser)

    def _state_parser(self, subparsers):
        state_parser = subparsers.add_parser('state')
        state_parser.add_argument("-p", "--power", type=str, choices=["on", "off"], default="on",
            help='Weather to set power to "on" or "off"')
        state_parser.add_argument("-b", "--brightness", type=float,
            help='Brightness Help')
        state_parser.add_argument("-H", "--hue", type=float,
            help='Hue help')
        state_parser.add_argument("-k", "--kelvin", type=int,
            help='Kelvin help')
        state_parser.add_argument("-s", "--saturation", type=float,
            help='Saturation help')
        self._color_parser(state_parser)
        self._addDurationArgument(state_parser)
        self._addSelectorGroup(state_parser)

    def _toggle_parser(self, subparsers):
        toggle_parser = subparsers.add_parser('toggle')
        self._addDurationArgument(toggle_parser)
        self._addSelectorGroup(toggle_parser)

    def _addSelectorGroup(self, parser):
        groupSelector = parser.add_mutually_exclusive_group(required=False)
        groupSelector.set_defaults(selector='all')
        groupSelector.add_argument("-g", "--group", type=str)
        groupSelector.add_argument("-l", "--label", type=str)
        groupSelector.add_argument("-L", "--location", type=str)

    def _color_parser(self, parser):
        groupColor = parser.add_mutually_exclusive_group(required=False)
        groupColor.add_argument("-c", "--color", type=str,
            help='Color or hex value, e.g. "red" alternatively RRGGBB')
        groupColor.add_argument("-r", "--rgb", type=int, nargs=3,
            help='rgb in format [1-255] [1-255] [1-255]')

    def _addDurationArgument(self, parser):
        parser.add_argument("-d", "--duration", type=float, default=1.0,
            help='Duration for transition')

    def _addVerboseArgument(self, parser):
        parser.add_argument("-v", "--verbose", dest='verbose', action='store_true',
             help='Duration for transition')

######################################
def error_exit(msg=None):
    if msg != None:
        print(msg)
    sys.exit(1)

def not_none_exists(*values):
    for value in values:
        if value is not None:
            return True
    return False

############### MAIN ################
def main(argv):

    parser = Parser().parser()

    args = parser.parse_args()

    #print(vars(args))
    binds = {"on" : LIFX.power,
             "off" : LIFX.power,
             "state" : LIFX.state,
             "list" : LIFX.list,
             "toggle" : LIFX.toggle}

    binds[args.sub_action](LIFX(), args)
    sys.exit(0)

if __name__ == "__main__":
   main(sys.argv[1:])
