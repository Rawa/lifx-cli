#!/usr/bin/python2.7

#
# Simple script to control your LIFX lamps using the cli by doing RESTful calls
# to the lifx api. Needs a valid lifx token to make requests, the token should
# be saved in $HOME/.config/lifx/lifx_token
#
# @author David Goransson
#

from StringIO import StringIO
import os, pycurl, sys, json, getopt

version = '1.0b'
verbose = False
URL = 'https://api.lifx.com/v1beta1/lights/SELECTOR/ACTION'
actions = ("power", "toggle", "list", "color", "--version")

home = os.getenv("HOME")
config_path = home + "/.config/lifx/lifx_token"
f = open(config_path,'r')
token = f.readline().rstrip()
f.close()

############### ConnectionHandle ###################
class ConnectionHandle:
    def ___init__(self):
        pass

    def _send_request(self, c):
        storage = StringIO()

        c.setopt(c.WRITEFUNCTION, storage.write)
        c.setopt(pycurl.CONNECTTIMEOUT, 5)
        c.setopt(pycurl.TIMEOUT, 5)
        c.setopt(pycurl.USERPWD, token)
        try:
           c.perform()
        except pycurl.error:
            error_exit("Timeout - Unable to reach the server, verify your internet connection")

        content = storage.getvalue()
        http_code = c.getinfo(pycurl.HTTP_CODE)
        c.close()
        handle_response(http_code, content)

        return http_code, content

    def _build_url(self, selector, action):
        url = URL.replace("SELECTOR", selector)
        url = url.replace("ACTION", action)
        return url

    def send_put(self, selector, action, data):
        c = pycurl.Curl()
        c.setopt(pycurl.CUSTOMREQUEST, "PUT")
        c.setopt(pycurl.URL, self._build_url(selector, action))
        c.setopt(pycurl.POSTFIELDS, data)
        return self._send_request(c);

    def send_post(self, selector, action, data):
        c = pycurl.Curl()
        c.setopt(pycurl.POST, 1)
        c.setopt(pycurl.POSTFIELDS, data)
        c.setopt(pycurl.URL, self._build_url(selector, action))
        return self._send_request(c)

    def send_get(self, selector):
        c = pycurl.Curl()
        c.setopt(pycurl.URL, self._build_url(selector, ""))
        return self._send_request(c)

############### LIFX ###################
class LIFX:
    def ___init__(self):
        pass

    # TOGGLE: POST /v1beta1/lights/:selector/toggle
    def toggle(self, selector):
        return ConnectionHandle().send_post(selector, "toggle", "")

    # POWER: PUT /v1beta1/lights/:selector/power
    def power(self, state, duration, selector):
        return ConnectionHandle().send_put(selector, "power", "state=" + state + "&duration=" + duration)

    # LIST: GET /v1beta1/lights/:selector
    def list_lamps(self, selector):
        return ConnectionHandle().send_get(selector)

    # COLOR: PUT /v1beta1/lights/:selector/color
    def color(self, color, duration, selector):
        return ConnectionHandle().send_put(selector, "color", "color=" + color + "&duration=" + duration)

############### Parser ###################
class Parser:
    def ___init__(self):
        pass

    def duration(self, arg):
        options, remainder = getopt.getopt(arg[1:], 'd:', ["duration=" ])

        for opt, arg in options:
            if opt in ('-d', '--duration'):
                return arg, remainder

        #Return default value
        return "1.0", remainder

    def selector(self, arg):
        options, remainder = getopt.getopt(arg, 'al:g:L:', ["all", "label=", "group=", "location=" ])

        #Default select all
        selector="all"

        if(len(options) > 1):
            error_exit("Too many selectors!")

        for opt, arg in options:
            if opt in ('-a', '--all'):
                selector = "all"
            elif opt in ('-l', '--label'):
                selector = "label:" + arg
            elif opt in ('-g', '--group'):
                selector = "group:" + arg
            elif opt in ('-L', '--location'):
                selector = "location:" + arg

        return selector, remainder

    def color(self, arg):
        options, remainder = getopt.getopt(arg, 'b:h:s:k:r:d:al:g:L:', ["brightness=", "hue=", "kelvin=", "rgb=", "saturation="])


        colors = ("white", "red", "orange", "yellow", "cyan", "green", "blue", "purple", "pink")
        if (arg[0] in colors or arg[0].startswith("#")):
            if(len(arg) > 1):
                error_exit("Too many arguments, color or hex may not use additional arguments")
            return arg[0], remainder

        for opt, rgb in options:
            if opt in ('-r', '--rgb'):
                if(len(arg) > 3):
                    error_exit("Too many arguments, rgb can't be combined")
                color = "rgb:" + rgb
                return (color, remainder)

        color = ""
        for opt, arg in options:
            if opt in ('-b', '--brightness'):
                color = color + "&brightness:" + arg
            elif opt in ('-h', '--hue'):
                color = color + "&hue:" + arg
            elif opt in ('-k', '--kelvin'):
                color = color + "&kelvin:" + arg
            elif opt in ('-s', '--saturation'):
                color = color + "&saturation:" + arg
        color = color[1:]
        return color, remainder

######################################

def print_help():
    print("lifx [ACTION]")
    for action in actions:
        print("      " + action)

def error_exit(msg=None):
    if msg != None:
        print(msg)
    sys.exit(1)

def handle_response(code, content):
    if code in (200 ,201, 202, 207):
        return;
    elif code == 401:
        print("Unauthorized request - Verify your lifx token")
    elif code == 408:
        print("Request timed out -  Light unreachable!")
    elif code == 429:
        print("Too many requests!")
    elif code in (500, 502, 503, 523):
        print("Server error!")
    else:
        print("Unknown error! HTTP Code: " + str(code))

    print("Server response:")
    print(content)
    sys.exit(1)

def print_help_duration():
    print("""
    [OPTIONS]:
        -d, --duration                  Duration for the giving action until end
                                        state (default 1)""")

def print_help_selector():
    print("""
    [SELECTOR]:
        -a, --all                       Select all lights (default)
        -l, --label=LABEL               LABEL is the label of the light
        -g, --group=GROUP               GROUP is the group of the light(s)
        -L, --location=LOCATION         LOCATION is the location of the light""")

def handle_remainder(remainder):
    if len(remainder) == 0:
        return
    error_exit("Error, unknown command: " + ' '.join(remainder))

############### POWER ################
def print_help_power():
    print("""lifx power [ARGUMENT] [OPTIONS] [SELECTOR]
    [ARGUMENT]:
        on                              Turn the power on
        off                             Turn the power off""")
    print_help_duration()
    print_help_selector()

def handle_power(arg):
    if len(arg) < 1 or arg[0] not in ("on", "off"):
        print_help_power()
        error_exit()

    duration, rest = Parser().duration(arg[1:])
    selector, remainder = Parser().selector(rest)
    handle_remainder(remainder)

    LIFX().power(arg[0], duration, selector)

############### TOGGLE ################
def print_help_toggle():
    print("""lifx toggle [SELECTOR]""")
    print_help_selector()

def handle_toggle(arg):
    selector, remainder = Parser().selector(arg)
    handle_remainder(remainder)
    LIFX().toggle(selector)

############### LIST ################
def print_help_list():
    print("""lifx list [SELECTOR]""")
    print_help_selector()

def handle_list(arg):
    selector, remainder = Parser().selector(arg)
    handle_remainder(remainder)
    code, data = LIFX().list_lamps(selector)
    decoded = json.loads(data)
    print("[Label] - [Location]/[Group]\n")
    for item in decoded:
        print(item['label'] + " - " + item['location']['name'] + "/" + item['group']['name'])
        print("  power      : " + item['power'])
        print("  hue        : " + str(item['color']['hue']))
        print("  kelvin     : " + str(item['color']['kelvin']))
        print("  saturation : " + str(item['color']['saturation']))
        print("  brightness : " + str(item['brightness']))

############### COLOR ################
def print_help_color():
    print("""lifx color [ARGUMENT] [OPTIONS] [SELECTOR]
    [ARGUMENT]:
        [TEXT-COLOR]                    Any of the following colors: white, red
                                        orange, yellow, cyan, green, blue,
                                        purple, pink
        [#RRGGBB]                       RGB Hex representation of color
        -b, --brightness=BRIGHTNESS     BRIGHTNESS value between 0.0-1.0
        -h, --hue=HUE                   HUE value between 0-360
        -k. --kelvin=KELVIN             KELVIN value between 2500-9000
        -r, --rgb=RGB                   RGB is a triple [0-255],[0-255],[0-255]    BRIGHTNESS
        -s, --saturation=SATURATION     SATURATION value between 0.0-1.0""")
    print_help_duration()
    print_help_selector()

def handle_color(arg):
    if len(arg) < 1:
        print_help_color()
        error_exit()

    color, rest = Parser().color(arg)
    duration, rest = Parser().duration(rest)
    selector, remainder = Parser().selector(rest)
    handle_remainder(remainder)

    LIFX().color(color, duration, selector)

def main(argv):
    if len(argv) < 1 or argv[0] not in actions:
        print_help()
        sys.exit()

    action = argv[0]
    args = argv[1:]
    if action == "power":
        handle_power(args)
    elif action == "toggle":
        handle_toggle(args)
    elif action == "list":
        handle_list(args)
    elif action == "color":
        handle_color(args)
    elif action == "--version":
        print(version)
    sys.exit(0)

if __name__ == "__main__":
   main(sys.argv[1:])
